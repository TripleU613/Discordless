<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="refresh" content="120">
  <title>Forums Temporarily Offline</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #111827;
      --accent: #38bdf8;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: rgba(56, 189, 248, 0.25);
      --terminal-text: #7dd3fc;
      --terminal-accent: #60a5fa;
      --terminal-bg: #0b1323;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Inter", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      min-height: 100vh;
      background: radial-gradient(1200px 600px at 20% 10%, rgba(56, 189, 248, 0.15), transparent 60%),
                  radial-gradient(800px 400px at 90% 80%, rgba(59, 130, 246, 0.2), transparent 65%),
                  var(--bg);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .wrap {
      width: 100%;
      max-width: 1180px;
      display: grid;
      gap: 20px;
    }
    .card {
      background: rgba(17, 24, 39, 0.85);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 28px 30px;
      text-align: center;
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.5);
      position: relative;
      overflow: hidden;
    }
    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(600px 180px at 50% 0%, rgba(56, 189, 248, 0.18), transparent 70%);
      pointer-events: none;
    }
    .hero {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 10px;
      justify-items: center;
    }
    h1 {
      font-size: 28px;
      margin-bottom: 6px;
      letter-spacing: -0.3px;
    }
    p {
      font-size: 16px;
      color: var(--muted);
      line-height: 1.5;
      margin-bottom: 6px;
    }
    .status {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(56, 189, 248, 0.08);
      font-size: 12px;
      color: var(--accent);
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 14px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(56, 189, 248, 0.9);
      animation: pulse 1.6s ease-in-out infinite;
    }
    .note {
      font-size: 13px;
      color: var(--muted);
      margin-top: 2px;
    }
    .progress {
      width: min(520px, 82%);
      height: 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      border: 1px solid rgba(56, 189, 248, 0.25);
      overflow: hidden;
      position: relative;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.35);
    }
    .progress::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(56, 189, 248, 0.35), transparent);
      animation: shimmer 2.2s ease-in-out infinite;
    }
    .progress-bar {
      height: 100%;
      width: 45%;
      border-radius: inherit;
      background: linear-gradient(90deg, rgba(56, 189, 248, 0.2), rgba(56, 189, 248, 0.8), rgba(59, 130, 246, 0.9));
      animation: load-slide 1.8s ease-in-out infinite;
      box-shadow: 0 0 14px rgba(56, 189, 248, 0.6);
    }
    .progress-label {
      font-size: 12px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .mobile-info {
      display: none;
      width: 100%;
      margin-top: 8px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.6);
      text-align: left;
      gap: 8px;
    }
    .mobile-info__item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
      color: var(--muted);
      letter-spacing: 0.02em;
    }
    .mobile-info__value {
      color: var(--text);
      font-weight: 600;
    }
    .panel-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      grid-template-areas: "game logs";
      gap: 20px;
      align-items: stretch;
    }
    .game {
      grid-area: game;
      background: rgba(17, 24, 39, 0.7);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.4);
    }
    .game-title {
      font-size: 16px;
      font-weight: 700;
      margin: 4px 4px 10px;
      color: var(--text);
    }
    .game-shell {
      width: 100%;
      height: clamp(220px, 42vh, 360px);
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      touch-action: manipulation;
      overscroll-behavior: contain;
    }
    .game-shell iframe {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }
    .game-note {
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
    }
    .logs {
      grid-area: logs;
      background: rgba(12, 18, 30, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.4);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 12px;
    }
    .log-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .log-title {
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
    }
    .log-status {
      font-size: 12px;
      color: var(--muted);
    }
    .log-output {
      background: var(--terminal-bg);
      border-radius: 12px;
      border: 1px solid rgba(125, 211, 252, 0.35);
      color: var(--terminal-text);
      font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      line-height: 1.5;
      padding: 12px;
      height: clamp(220px, 42vh, 360px);
      overflow: auto;
      white-space: pre-wrap;
      box-shadow: inset 0 0 24px rgba(15, 23, 42, 0.6),
                  0 0 18px rgba(96, 165, 250, 0.18);
      scrollbar-width: none;
      -ms-overflow-style: none;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      gap: 2px;
    }
    .log-line {
      white-space: pre-wrap;
      word-break: break-word;
      text-shadow: 0 0 8px rgba(125, 211, 252, 0.2);
    }
    .log-output::-webkit-scrollbar {
      width: 0;
      height: 0;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.7; }
    }
    @keyframes load-slide {
      0% { transform: translateX(-110%); }
      50% { transform: translateX(15%); }
      100% { transform: translateX(120%); }
    }
    @keyframes shimmer {
      0% { transform: translateX(-60%); opacity: 0.25; }
      60% { transform: translateX(90%); opacity: 0.55; }
      100% { transform: translateX(140%); opacity: 0.1; }
    }
    @media (max-width: 900px) {
      body {
        padding: 18px;
        align-items: center;
        background: #0a0e27;
        overflow: hidden;
      }
      body::before,
      body::after {
        content: "";
        position: fixed;
        width: 320px;
        height: 320px;
        border-radius: 50%;
        filter: blur(70px);
        opacity: 0.45;
        z-index: 0;
        pointer-events: none;
      }
      body::before {
        top: -120px;
        right: -120px;
        background: #3b82f6;
      }
      body::after {
        bottom: -120px;
        left: -120px;
        background: #60a5fa;
      }
      .wrap {
        gap: 16px;
        width: 100%;
        max-width: 520px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
      }
      .panel-row { display: none; }
      .card {
        padding: 28px 22px;
        width: 100%;
        border-radius: 24px;
        border: 1px solid rgba(59, 130, 246, 0.22);
        background: rgba(17, 24, 39, 0.82);
        box-shadow: 0 0 60px rgba(59, 130, 246, 0.22),
                    0 20px 60px rgba(0, 0, 0, 0.45),
                    inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }
      .card::after {
        background: radial-gradient(420px 180px at 50% 0%, rgba(59, 130, 246, 0.18), transparent 70%);
      }
      h1 {
        font-size: 26px;
        text-shadow: 0 0 28px rgba(59, 130, 246, 0.45);
      }
      p {
        font-size: 15px;
        color: #94a3b8;
      }
      .status {
        border-radius: 12px;
        border: 1px solid rgba(59, 130, 246, 0.3);
        background: rgba(59, 130, 246, 0.1);
        color: #60a5fa;
        letter-spacing: 0.08em;
      }
      .dot {
        width: 12px;
        height: 12px;
        background: #3b82f6;
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
        animation: pulse 2s ease-in-out infinite;
      }
      .mobile-info { display: none; }
      .progress {
        width: 100%;
        height: 6px;
        border-radius: 6px;
        border: 0;
        background: rgba(59, 130, 246, 0.15);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
      }
      .progress::before { display: none; }
      .progress-bar {
        position: absolute;
        inset: 0 auto 0 0;
        width: 40%;
        border-radius: 6px;
        background: linear-gradient(90deg, rgba(59, 130, 246, 0), #3b82f6, #60a5fa, #3b82f6, rgba(59, 130, 246, 0));
        box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
        animation: mobile-slide 2s linear infinite;
      }
      .progress-label {
        font-size: 12px;
        letter-spacing: 0.16em;
        color: #64748b;
      }
      .note {
        font-size: 13px;
        color: #64748b;
      }
    }
    @media (max-width: 720px) {
      .card { padding: 18px 18px; }
      h1 { font-size: 22px; }
      p { font-size: 14px; line-height: 1.45; }
      .progress-label { letter-spacing: 0.12em; }
    }
    @media (max-width: 600px) {
      body { padding: 12px; }
      .wrap { max-width: 100%; }
      .card { padding: 22px 18px; }
      h1 { font-size: 24px; }
      p { font-size: 14px; }
    }
    @media (max-height: 680px) {
      .card { padding: 16px 14px; }
    }
    @keyframes mobile-slide {
      0% { transform: translateX(-140%); }
      100% { transform: translateX(240%); }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="card">
      <div class="hero">
        <div class="status"><span class="dot"></span>Rebuilding</div>
        <h1>Forums Temporarily Offline</h1>
        <p>We are rebuilding or starting up the Discourse container. This page will refresh automatically every 2 minutes and return you to the forums as soon as they are available.</p>
        <div class="mobile-info" aria-hidden="true">
          <div class="mobile-info__item">
            <span>Auto refresh</span>
            <span class="mobile-info__value">Every 2 minutes</span>
          </div>
          <div class="mobile-info__item">
            <span>Status</span>
            <span class="mobile-info__value">Rebuilding</span>
          </div>
        </div>
        <div class="progress" aria-hidden="true">
          <div class="progress-bar"></div>
        </div>
        <div class="progress-label">Restoring services</div>
        <div class="note">Thanks for your patience.</div>
      </div>
    </section>

    <div class="panel-row">
      <section class="game">
        <div class="game-title">Play while you wait</div>
        <div class="game-shell">
          <iframe src="/errorpages/t-rex/index.html?v=20260204c" title="Chrome Dino Runner (Pygame)" loading="lazy" allow="clipboard-write; web-share"></iframe>
        </div>
        <div class="game-note" aria-hidden="true"></div>
      </section>

      <section class="logs">
        <div class="log-header">
          <div class="log-title">Live Discourse Logs</div>
          <div class="log-status" id="log-status">Connecting…</div>
        </div>
        <div class="log-output" id="log-output">
          <div class="log-line">Waiting for logs…</div>
        </div>
      </section>
    </div>
  </main>
  <script>
    (() => {
      const logOutput = document.getElementById("log-output");
      const logStatus = document.getElementById("log-status");
      const logUrl = "/errorpages/logs/discourse.log";
      const streamUrl = "/errorpages/logs/stream";
      const refreshMs = 2000;
      const maxLines = 2000;
      const flushDelay = 80;
      const seenLimit = 3000;
      let pending = [];
      let flushTimer = null;
      let pollTimer = null;
      let lastSnapshot = null;
      let hasLines = false;
      let lastTimestamp = null;
      let seenQueue = [];
      let seenSet = new Set();
      let lastLineAt = null;
      let lastStatusLine = null;
      let lastStatusAt = 0;
      function updateStatus(text) {
        if (logStatus) {
          logStatus.textContent = text;
        }
      }

      function parseLogTimestamp(line) {
        const match = line.match(
          /^(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})(\.\d+)?Z\b/
        );
        if (!match) return null;
        const base = Date.parse(`${match[1]}Z`);
        if (Number.isNaN(base)) return null;
        if (!match[2]) return base;
        const fraction = match[2].slice(1);
        const ms = parseInt(fraction.slice(0, 3).padEnd(3, "0"), 10) || 0;
        return base + ms;
      }

      function rememberLine(line) {
        if (!line) return true;
        if (seenSet.has(line)) return false;
        seenSet.add(line);
        seenQueue.push(line);
        while (seenQueue.length > seenLimit) {
          const oldLine = seenQueue.shift();
          if (oldLine) {
            seenSet.delete(oldLine);
          }
        }
        return true;
      }

      function scheduleFlush() {
        if (flushTimer) return;
        flushTimer = setTimeout(() => {
          flushTimer = null;
          if (!pending.length) return;
          const fragment = document.createDocumentFragment();
          for (const line of pending) {
            const item = document.createElement("div");
            item.className = "log-line";
            item.textContent = line;
            fragment.appendChild(item);
          }
          pending = [];
          logOutput.appendChild(fragment);

          while (logOutput.childNodes.length > maxLines) {
            logOutput.removeChild(logOutput.firstChild);
          }

          logOutput.scrollTop = logOutput.scrollHeight;
        }, flushDelay);
      }

      function resetLogs(message, clearMemory = true) {
        if (!logOutput) return;
        pending = [];
        if (flushTimer) {
          clearTimeout(flushTimer);
          flushTimer = null;
        }
        logOutput.textContent = "";
        if (message) {
          const item = document.createElement("div");
          item.className = "log-line";
          item.textContent = message;
          logOutput.appendChild(item);
        }
        logOutput.scrollTop = logOutput.scrollHeight;
        if (clearMemory) {
          hasLines = false;
          lastSnapshot = null;
          lastTimestamp = null;
          seenQueue = [];
          seenSet = new Set();
        }
      }

      function addLine(line) {
        if (!logOutput) return;
        if (line && /\[rebuild\]|rebuild start/i.test(line)) {
          resetLogs("Rebuild starting…", true);
        }
        const ts = parseLogTimestamp(line);
        if (ts !== null) {
          if (lastTimestamp !== null && ts + 1000 < lastTimestamp) {
            return;
          }
          if (lastTimestamp === null || ts > lastTimestamp) {
            lastTimestamp = ts;
          }
        }
        if (!rememberLine(line)) {
          return;
        }
        hasLines = true;
        pending.push(line);
        lastLineAt = new Date();
        updateStatus(`Streaming · ${lastLineAt.toLocaleTimeString()}`);
        scheduleFlush();
      }

      function addStatusLine(text) {
        const now = Date.now();
        if (text === lastStatusLine && now - lastStatusAt < 10000) {
          return;
        }
        lastStatusLine = text;
        lastStatusAt = now;
        addLine(`[status] ${text}`);
      }

      function startPolling() {
        if (pollTimer) return;
        updateStatus("Polling logs…");
        if (!hasLines) {
          resetLogs("Polling logs…", true);
        }
        const fetchLogs = async () => {
          if (!logOutput) return;
          try {
            const response = await fetch(`${logUrl}?t=${Date.now()}`, {
              cache: "no-store",
            });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const text = await response.text();
            if (text === lastSnapshot) {
              return;
            }
            lastSnapshot = text;
            resetLogs(null, true);
            const lines = (text || "No logs yet.").split("\n");
            for (const line of lines) {
              const item = document.createElement("div");
              item.className = "log-line";
              item.textContent = line;
              logOutput.appendChild(item);
            }
            logOutput.scrollTop = logOutput.scrollHeight;
            hasLines = true;
            const now = new Date();
            updateStatus(`Updated ${now.toLocaleTimeString()}`);
          } catch (error) {
            updateStatus(`Log fetch failed`);
            resetLogs("Log stream unavailable. Waiting for Discourse to respond.", false);
          }
        };

        fetchLogs();
        pollTimer = setInterval(fetchLogs, refreshMs);
      }

      function startStream() {
        if (!window.EventSource) {
          startPolling();
          return;
        }

        const stream = new EventSource(streamUrl);
        updateStatus("Connecting…");
        if (!hasLines) {
          resetLogs("Connecting…", false);
        }

        stream.onopen = () => {
          updateStatus("Streaming…");
        };

        stream.addEventListener("status", (event) => {
          if (event && event.data) {
            updateStatus(event.data);
            addStatusLine(event.data);
          }
        });

        stream.onmessage = (event) => {
          if (!event || !event.data) return;
          addLine(event.data);
        };

        stream.onerror = () => {
          updateStatus("Reconnecting…");
        };
      }

      startStream();
    })();
  </script>
</body>
</html>
